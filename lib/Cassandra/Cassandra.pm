# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Cassandra::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Cassandra::Cassandra_login_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_login_args->mk_accessors( qw( auth_request ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{auth_request} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{auth_request}) {
      $self->{auth_request} = $vals->{auth_request};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_login_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{auth_request} = new Cassandra::AuthenticationRequest();
        $xfer += $self->{auth_request}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_login_args');
  if (defined $self->{auth_request}) {
    $xfer += $output->writeFieldBegin('auth_request', TType::STRUCT, 1);
    $xfer += $self->{auth_request}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_login_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_login_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authnx} = undef;
  $self->{authzx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authnx}) {
      $self->{authnx} = $vals->{authnx};
    }
    if (defined $vals->{authzx}) {
      $self->{authzx} = $vals->{authzx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_login_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{authnx} = new Cassandra::AuthenticationException();
        $xfer += $self->{authnx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{authzx} = new Cassandra::AuthorizationException();
        $xfer += $self->{authzx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_login_result');
  if (defined $self->{authnx}) {
    $xfer += $output->writeFieldBegin('authnx', TType::STRUCT, 1);
    $xfer += $self->{authnx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{authzx}) {
    $xfer += $output->writeFieldBegin('authzx', TType::STRUCT, 2);
    $xfer += $self->{authzx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_keyspace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_keyspace_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_args->mk_accessors( qw( key column_path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_path} = new Cassandra::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', TType::STRUCT, 2);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{nfe} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::ColumnOrSuperColumn();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{nfe} = new Cassandra::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 3);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 4);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_slice_args->mk_accessors( qw( key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size88 = 0;
          $self->{success} = [];
          my $_etype91 = 0;
          $xfer += $input->readListBegin(\$_etype91, \$_size88);
          for (my $_i92 = 0; $_i92 < $_size88; ++$_i92)
          {
            my $elem93 = undef;
            $elem93 = new Cassandra::ColumnOrSuperColumn();
            $xfer += $elem93->read($input);
            push(@{$self->{success}},$elem93);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter94 (@{$self->{success}}) 
        {
          $xfer += ${iter94}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_count_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_count_args->mk_accessors( qw( key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_count_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_slice_args->mk_accessors( qw( keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size95 = 0;
          $self->{keys} = [];
          my $_etype98 = 0;
          $xfer += $input->readListBegin(\$_etype98, \$_size95);
          for (my $_i99 = 0; $_i99 < $_size95; ++$_i99)
          {
            my $elem100 = undef;
            $xfer += $input->readString(\$elem100);
            push(@{$self->{keys}},$elem100);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_args');
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter101 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter101);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size102 = 0;
          $self->{success} = {};
          my $_ktype103 = 0;
          my $_vtype104 = 0;
          $xfer += $input->readMapBegin(\$_ktype103, \$_vtype104, \$_size102);
          for (my $_i106 = 0; $_i106 < $_size102; ++$_i106)
          {
            my $key107 = '';
            my $val108 = [];
            $xfer += $input->readString(\$key107);
            {
              my $_size109 = 0;
              $val108 = [];
              my $_etype112 = 0;
              $xfer += $input->readListBegin(\$_etype112, \$_size109);
              for (my $_i113 = 0; $_i113 < $_size109; ++$_i113)
              {
                my $elem114 = undef;
                $elem114 = new Cassandra::ColumnOrSuperColumn();
                $xfer += $elem114->read($input);
                push(@{$val108},$elem114);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key107} = $val108;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter115,$viter116) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter115);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter116}}));
            {
              foreach my $iter117 (@{${viter116}}) 
              {
                $xfer += ${iter117}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_count_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_count_args->mk_accessors( qw( keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size118 = 0;
          $self->{keys} = [];
          my $_etype121 = 0;
          $xfer += $input->readListBegin(\$_etype121, \$_size118);
          for (my $_i122 = 0; $_i122 < $_size118; ++$_i122)
          {
            my $elem123 = undef;
            $xfer += $input->readString(\$elem123);
            push(@{$self->{keys}},$elem123);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_count_args');
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter124 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter124);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_count_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size125 = 0;
          $self->{success} = {};
          my $_ktype126 = 0;
          my $_vtype127 = 0;
          $xfer += $input->readMapBegin(\$_ktype126, \$_vtype127, \$_size125);
          for (my $_i129 = 0; $_i129 < $_size125; ++$_i129)
          {
            my $key130 = '';
            my $val131 = 0;
            $xfer += $input->readString(\$key130);
            $xfer += $input->readI32(\$val131);
            $self->{success}->{$key130} = $val131;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter132,$viter133) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter132);
          $xfer += $output->writeI32($viter133);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_range_slices_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_range_slices_args->mk_accessors( qw( column_parent predicate range consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{range} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{range}) {
      $self->{range} = $vals->{range};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slices_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{range} = new Cassandra::KeyRange();
        $xfer += $self->{range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slices_args');
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 1);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 2);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{range}) {
    $xfer += $output->writeFieldBegin('range', TType::STRUCT, 3);
    $xfer += $self->{range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_range_slices_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_range_slices_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slices_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size134 = 0;
          $self->{success} = [];
          my $_etype137 = 0;
          $xfer += $input->readListBegin(\$_etype137, \$_size134);
          for (my $_i138 = 0; $_i138 < $_size134; ++$_i138)
          {
            my $elem139 = undef;
            $elem139 = new Cassandra::KeySlice();
            $xfer += $elem139->read($input);
            push(@{$self->{success}},$elem139);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter140 (@{$self->{success}}) 
        {
          $xfer += ${iter140}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_indexed_slices_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_indexed_slices_args->mk_accessors( qw( column_parent index_clause column_predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_parent} = undef;
  $self->{index_clause} = undef;
  $self->{column_predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{index_clause}) {
      $self->{index_clause} = $vals->{index_clause};
    }
    if (defined $vals->{column_predicate}) {
      $self->{column_predicate} = $vals->{column_predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_indexed_slices_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{index_clause} = new Cassandra::IndexClause();
        $xfer += $self->{index_clause}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{column_predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_indexed_slices_args');
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 1);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_clause}) {
    $xfer += $output->writeFieldBegin('index_clause', TType::STRUCT, 2);
    $xfer += $self->{index_clause}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_predicate}) {
    $xfer += $output->writeFieldBegin('column_predicate', TType::STRUCT, 3);
    $xfer += $self->{column_predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_indexed_slices_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_indexed_slices_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_indexed_slices_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size141 = 0;
          $self->{success} = [];
          my $_etype144 = 0;
          $xfer += $input->readListBegin(\$_etype144, \$_size141);
          for (my $_i145 = 0; $_i145 < $_size141; ++$_i145)
          {
            my $elem146 = undef;
            $elem146 = new Cassandra::KeySlice();
            $xfer += $elem146->read($input);
            push(@{$self->{success}},$elem146);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_indexed_slices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter147 (@{$self->{success}}) 
        {
          $xfer += ${iter147}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_insert_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_insert_args->mk_accessors( qw( key column_parent column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::Column();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 3);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_insert_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_insert_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_add_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_add_args->mk_accessors( qw( key column_parent column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_add_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::CounterColumn();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_add_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 3);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_add_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_add_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_add_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_add_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_args->mk_accessors( qw( key column_path timestamp consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{timestamp} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_path} = new Cassandra::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', TType::STRUCT, 2);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_counter_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_counter_args->mk_accessors( qw( key path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_counter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Cassandra::ColumnPath();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_counter_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 2);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_counter_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_counter_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_counter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_counter_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_batch_mutate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_batch_mutate_args->mk_accessors( qw( mutation_map consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation_map} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation_map}) {
      $self->{mutation_map} = $vals->{mutation_map};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size148 = 0;
          $self->{mutation_map} = {};
          my $_ktype149 = 0;
          my $_vtype150 = 0;
          $xfer += $input->readMapBegin(\$_ktype149, \$_vtype150, \$_size148);
          for (my $_i152 = 0; $_i152 < $_size148; ++$_i152)
          {
            my $key153 = '';
            my $val154 = [];
            $xfer += $input->readString(\$key153);
            {
              my $_size155 = 0;
              $val154 = {};
              my $_ktype156 = 0;
              my $_vtype157 = 0;
              $xfer += $input->readMapBegin(\$_ktype156, \$_vtype157, \$_size155);
              for (my $_i159 = 0; $_i159 < $_size155; ++$_i159)
              {
                my $key160 = '';
                my $val161 = [];
                $xfer += $input->readString(\$key160);
                {
                  my $_size162 = 0;
                  $val161 = [];
                  my $_etype165 = 0;
                  $xfer += $input->readListBegin(\$_etype165, \$_size162);
                  for (my $_i166 = 0; $_i166 < $_size162; ++$_i166)
                  {
                    my $elem167 = undef;
                    $elem167 = new Cassandra::Mutation();
                    $xfer += $elem167->read($input);
                    push(@{$val161},$elem167);
                  }
                  $xfer += $input->readListEnd();
                }
                $val154->{$key160} = $val161;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{mutation_map}->{$key153} = $val154;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_mutate_args');
  if (defined $self->{mutation_map}) {
    $xfer += $output->writeFieldBegin('mutation_map', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{mutation_map}}));
      {
        while( my ($kiter168,$viter169) = each %{$self->{mutation_map}}) 
        {
          $xfer += $output->writeString($kiter168);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{${viter169}}));
            {
              while( my ($kiter170,$viter171) = each %{${viter169}}) 
              {
                $xfer += $output->writeString($kiter170);
                {
                  $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter171}}));
                  {
                    foreach my $iter172 (@{${viter171}}) 
                    {
                      $xfer += ${iter172}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_batch_mutate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_batch_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_mutate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_truncate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_truncate_args->mk_accessors( qw( cfname ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfname} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfname}) {
      $self->{cfname} = $vals->{cfname};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_truncate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cfname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_truncate_args');
  if (defined $self->{cfname}) {
    $xfer += $output->writeFieldBegin('cfname', TType::STRING, 1);
    $xfer += $output->writeString($self->{cfname});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_truncate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_truncate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_truncate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_truncate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_schema_versions_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_schema_versions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_schema_versions_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_schema_versions_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_schema_versions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_schema_versions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size173 = 0;
          $self->{success} = {};
          my $_ktype174 = 0;
          my $_vtype175 = 0;
          $xfer += $input->readMapBegin(\$_ktype174, \$_vtype175, \$_size173);
          for (my $_i177 = 0; $_i177 < $_size173; ++$_i177)
          {
            my $key178 = '';
            my $val179 = [];
            $xfer += $input->readString(\$key178);
            {
              my $_size180 = 0;
              $val179 = [];
              my $_etype183 = 0;
              $xfer += $input->readListBegin(\$_etype183, \$_size180);
              for (my $_i184 = 0; $_i184 < $_size180; ++$_i184)
              {
                my $elem185 = undef;
                $xfer += $input->readString(\$elem185);
                push(@{$val179},$elem185);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key178} = $val179;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_schema_versions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter186,$viter187) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter186);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter187}}));
            {
              foreach my $iter188 (@{${viter187}}) 
              {
                $xfer += $output->writeString($iter188);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspaces_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspaces_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspaces_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspaces_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspaces_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspaces_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size189 = 0;
          $self->{success} = [];
          my $_etype192 = 0;
          $xfer += $input->readListBegin(\$_etype192, \$_size189);
          for (my $_i193 = 0; $_i193 < $_size189; ++$_i193)
          {
            my $elem194 = undef;
            $elem194 = new Cassandra::KsDef();
            $xfer += $elem194->read($input);
            push(@{$self->{success}},$elem194);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspaces_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter195 (@{$self->{success}}) 
        {
          $xfer += ${iter195}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_cluster_name_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_cluster_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_cluster_name_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_cluster_name_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_cluster_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_cluster_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_cluster_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_version_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_version_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_version_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_version_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_version_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_version_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_version_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_ring_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_ring_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_ring_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_ring_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_ring_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_ring_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_ring_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size196 = 0;
          $self->{success} = [];
          my $_etype199 = 0;
          $xfer += $input->readListBegin(\$_etype199, \$_size196);
          for (my $_i200 = 0; $_i200 < $_size196; ++$_i200)
          {
            my $elem201 = undef;
            $elem201 = new Cassandra::TokenRange();
            $xfer += $elem201->read($input);
            push(@{$self->{success}},$elem201);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_ring_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter202 (@{$self->{success}}) 
        {
          $xfer += ${iter202}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_partitioner_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_partitioner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_partitioner_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_partitioner_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_partitioner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_partitioner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_partitioner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_snitch_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_snitch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_snitch_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_snitch_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_snitch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_snitch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_snitch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{nfe} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::KsDef();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{nfe} = new Cassandra::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', TType::STRUCT, 1);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 2);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_args->mk_accessors( qw( cfName start_token end_token keys_per_split ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfName} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{keys_per_split} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfName}) {
      $self->{cfName} = $vals->{cfName};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{keys_per_split}) {
      $self->{keys_per_split} = $vals->{keys_per_split};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cfName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{keys_per_split});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_args');
  if (defined $self->{cfName}) {
    $xfer += $output->writeFieldBegin('cfName', TType::STRING, 1);
    $xfer += $output->writeString($self->{cfName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 2);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 3);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys_per_split}) {
    $xfer += $output->writeFieldBegin('keys_per_split', TType::I32, 4);
    $xfer += $output->writeI32($self->{keys_per_split});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size203 = 0;
          $self->{success} = [];
          my $_etype206 = 0;
          $xfer += $input->readListBegin(\$_etype206, \$_size203);
          for (my $_i207 = 0; $_i207 < $_size203; ++$_i207)
          {
            my $elem208 = undef;
            $xfer += $input->readString(\$elem208);
            push(@{$self->{success}},$elem208);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter209 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter209);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_column_family_args->mk_accessors( qw( cf_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cf_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cf_def}) {
      $self->{cf_def} = $vals->{cf_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cf_def} = new Cassandra::CfDef();
        $xfer += $self->{cf_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_column_family_args');
  if (defined $self->{cf_def}) {
    $xfer += $output->writeFieldBegin('cf_def', TType::STRUCT, 1);
    $xfer += $self->{cf_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_column_family_args->mk_accessors( qw( column_family ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_column_family_args');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_keyspace_args->mk_accessors( qw( ks_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ks_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ks_def}) {
      $self->{ks_def} = $vals->{ks_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ks_def} = new Cassandra::KsDef();
        $xfer += $self->{ks_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_keyspace_args');
  if (defined $self->{ks_def}) {
    $xfer += $output->writeFieldBegin('ks_def', TType::STRUCT, 1);
    $xfer += $self->{ks_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_keyspace_args->mk_accessors( qw( ks_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ks_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ks_def}) {
      $self->{ks_def} = $vals->{ks_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ks_def} = new Cassandra::KsDef();
        $xfer += $self->{ks_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_keyspace_args');
  if (defined $self->{ks_def}) {
    $xfer += $output->writeFieldBegin('ks_def', TType::STRUCT, 1);
    $xfer += $self->{ks_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_column_family_args->mk_accessors( qw( cf_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cf_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cf_def}) {
      $self->{cf_def} = $vals->{cf_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cf_def} = new Cassandra::CfDef();
        $xfer += $self->{cf_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_column_family_args');
  if (defined $self->{cf_def}) {
    $xfer += $output->writeFieldBegin('cf_def', TType::STRUCT, 1);
    $xfer += $self->{cf_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CassandraIf;

use strict;


sub login{
  my $self = shift;
  my $auth_request = shift;

  die 'implement interface';
}

sub set_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub truncate{
  my $self = shift;
  my $cfname = shift;

  die 'implement interface';
}

sub describe_schema_versions{
  my $self = shift;

  die 'implement interface';
}

sub describe_keyspaces{
  my $self = shift;

  die 'implement interface';
}

sub describe_cluster_name{
  my $self = shift;

  die 'implement interface';
}

sub describe_version{
  my $self = shift;

  die 'implement interface';
}

sub describe_ring{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_partitioner{
  my $self = shift;

  die 'implement interface';
}

sub describe_snitch{
  my $self = shift;

  die 'implement interface';
}

sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  die 'implement interface';
}

sub system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

  die 'implement interface';
}

sub system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

  die 'implement interface';
}

sub system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

  die 'implement interface';
}

sub system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

  die 'implement interface';
}

sub system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

  die 'implement interface';
}

sub execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

package Cassandra::CassandraRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub login{
  my ($self, $request) = @_;

  my $auth_request = ($request->{'auth_request'}) ? $request->{'auth_request'} : undef;
  return $self->{impl}->login($auth_request);
}

sub set_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->set_keyspace($keyspace);
}

sub get{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get($key, $column_path, $consistency_level);
}

sub get_slice{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_slice($key, $column_parent, $predicate, $consistency_level);
}

sub get_count{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_count($key, $column_parent, $predicate, $consistency_level);
}

sub multiget_slice{
  my ($self, $request) = @_;

  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_slice($keys, $column_parent, $predicate, $consistency_level);
}

sub multiget_count{
  my ($self, $request) = @_;

  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_count($keys, $column_parent, $predicate, $consistency_level);
}

sub get_range_slices{
  my ($self, $request) = @_;

  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $range = ($request->{'range'}) ? $request->{'range'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_range_slices($column_parent, $predicate, $range, $consistency_level);
}

sub get_indexed_slices{
  my ($self, $request) = @_;

  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $index_clause = ($request->{'index_clause'}) ? $request->{'index_clause'} : undef;
  my $column_predicate = ($request->{'column_predicate'}) ? $request->{'column_predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
}

sub insert{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->insert($key, $column_parent, $column, $consistency_level);
}

sub add{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->add($key, $column_parent, $column, $consistency_level);
}

sub remove{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove($key, $column_path, $timestamp, $consistency_level);
}

sub remove_counter{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove_counter($key, $path, $consistency_level);
}

sub batch_mutate{
  my ($self, $request) = @_;

  my $mutation_map = ($request->{'mutation_map'}) ? $request->{'mutation_map'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->batch_mutate($mutation_map, $consistency_level);
}

sub truncate{
  my ($self, $request) = @_;

  my $cfname = ($request->{'cfname'}) ? $request->{'cfname'} : undef;
  return $self->{impl}->truncate($cfname);
}

sub describe_schema_versions{
  my ($self, $request) = @_;

  return $self->{impl}->describe_schema_versions();
}

sub describe_keyspaces{
  my ($self, $request) = @_;

  return $self->{impl}->describe_keyspaces();
}

sub describe_cluster_name{
  my ($self, $request) = @_;

  return $self->{impl}->describe_cluster_name();
}

sub describe_version{
  my ($self, $request) = @_;

  return $self->{impl}->describe_version();
}

sub describe_ring{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_ring($keyspace);
}

sub describe_partitioner{
  my ($self, $request) = @_;

  return $self->{impl}->describe_partitioner();
}

sub describe_snitch{
  my ($self, $request) = @_;

  return $self->{impl}->describe_snitch();
}

sub describe_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_keyspace($keyspace);
}

sub describe_splits{
  my ($self, $request) = @_;

  my $cfName = ($request->{'cfName'}) ? $request->{'cfName'} : undef;
  my $start_token = ($request->{'start_token'}) ? $request->{'start_token'} : undef;
  my $end_token = ($request->{'end_token'}) ? $request->{'end_token'} : undef;
  my $keys_per_split = ($request->{'keys_per_split'}) ? $request->{'keys_per_split'} : undef;
  return $self->{impl}->describe_splits($cfName, $start_token, $end_token, $keys_per_split);
}

sub system_add_column_family{
  my ($self, $request) = @_;

  my $cf_def = ($request->{'cf_def'}) ? $request->{'cf_def'} : undef;
  return $self->{impl}->system_add_column_family($cf_def);
}

sub system_drop_column_family{
  my ($self, $request) = @_;

  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  return $self->{impl}->system_drop_column_family($column_family);
}

sub system_add_keyspace{
  my ($self, $request) = @_;

  my $ks_def = ($request->{'ks_def'}) ? $request->{'ks_def'} : undef;
  return $self->{impl}->system_add_keyspace($ks_def);
}

sub system_drop_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->system_drop_keyspace($keyspace);
}

sub system_update_keyspace{
  my ($self, $request) = @_;

  my $ks_def = ($request->{'ks_def'}) ? $request->{'ks_def'} : undef;
  return $self->{impl}->system_update_keyspace($ks_def);
}

sub system_update_column_family{
  my ($self, $request) = @_;

  my $cf_def = ($request->{'cf_def'}) ? $request->{'cf_def'} : undef;
  return $self->{impl}->system_update_column_family($cf_def);
}

sub execute_cql_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->execute_cql_query($query, $compression);
}

package Cassandra::CassandraClient;


use base qw(Cassandra::CassandraIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub login{
  my $self = shift;
  my $auth_request = shift;

    $self->send_login($auth_request);
  $self->recv_login();
}

sub send_login{
  my $self = shift;
  my $auth_request = shift;

  $self->{output}->writeMessageBegin('login', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_login_args();
  $args->{auth_request} = $auth_request;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_login{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_login_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{authnx}) {
    die $result->{authnx}->why;
  }
  if (defined $result->{authzx}) {
    die $result->{authzx}->why;
  }
  return;
}
sub set_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_set_keyspace($keyspace);
  $self->recv_set_keyspace();
}

sub send_set_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('set_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_set_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_set_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  return;
}
sub get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

    $self->send_get($key, $column_path, $consistency_level);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_args();
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_get_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{nfe}) {
    die $result->{nfe}->getName();
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  die "get failed: unknown result";
}
sub get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_slice($key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_slice();
}

sub send_get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_slice', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_slice_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_get_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  die "get_slice failed: unknown result";
}
sub get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_count($key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_count();
}

sub send_get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_count', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_count_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_get_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  die "get_count failed: unknown result";
}
sub multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_slice($keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_slice();
}

sub send_multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_slice', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_multiget_slice_args();
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_multiget_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  die "multiget_slice failed: unknown result";
}
sub multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_count($keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_count();
}

sub send_multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_count', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_multiget_count_args();
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_multiget_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  die "multiget_count failed: unknown result";
}
sub get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

    $self->send_get_range_slices($column_parent, $predicate, $range, $consistency_level);
  return $self->recv_get_range_slices();
}

sub send_get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_range_slices', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_range_slices_args();
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{range} = $range;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_range_slices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_get_range_slices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  die "get_range_slices failed: unknown result";
}
sub get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

    $self->send_get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
  return $self->recv_get_indexed_slices();
}

sub send_get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_indexed_slices', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_indexed_slices_args();
  $args->{column_parent} = $column_parent;
  $args->{index_clause} = $index_clause;
  $args->{column_predicate} = $column_predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_indexed_slices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_get_indexed_slices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  die "get_indexed_slices failed: unknown result";
}
sub insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

    $self->send_insert($key, $column_parent, $column, $consistency_level);
  $self->recv_insert();
}

sub send_insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('insert', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_insert_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{column} = $column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  return;
}
sub add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

    $self->send_add($key, $column_parent, $column, $consistency_level);
  $self->recv_add();
}

sub send_add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('add', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_add_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{column} = $column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_add_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  return;
}
sub remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

    $self->send_remove($key, $column_path, $timestamp, $consistency_level);
  $self->recv_remove();
}

sub send_remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_remove_args();
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{timestamp} = $timestamp;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_remove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  return;
}
sub remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

    $self->send_remove_counter($key, $path, $consistency_level);
  $self->recv_remove_counter();
}

sub send_remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove_counter', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_remove_counter_args();
  $args->{key} = $key;
  $args->{path} = $path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove_counter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_remove_counter_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  return;
}
sub batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

    $self->send_batch_mutate($mutation_map, $consistency_level);
  $self->recv_batch_mutate();
}

sub send_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('batch_mutate', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_batch_mutate_args();
  $args->{mutation_map} = $mutation_map;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_batch_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_batch_mutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  return;
}
sub truncate{
  my $self = shift;
  my $cfname = shift;

    $self->send_truncate($cfname);
  $self->recv_truncate();
}

sub send_truncate{
  my $self = shift;
  my $cfname = shift;

  $self->{output}->writeMessageBegin('truncate', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_truncate_args();
  $args->{cfname} = $cfname;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_truncate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_truncate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  return;
}
sub describe_schema_versions{
  my $self = shift;

    $self->send_describe_schema_versions();
  return $self->recv_describe_schema_versions();
}

sub send_describe_schema_versions{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_schema_versions', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_schema_versions_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_schema_versions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_schema_versions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  die "describe_schema_versions failed: unknown result";
}
sub describe_keyspaces{
  my $self = shift;

    $self->send_describe_keyspaces();
  return $self->recv_describe_keyspaces();
}

sub send_describe_keyspaces{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_keyspaces', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_keyspaces_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspaces{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_keyspaces_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  die "describe_keyspaces failed: unknown result";
}
sub describe_cluster_name{
  my $self = shift;

    $self->send_describe_cluster_name();
  return $self->recv_describe_cluster_name();
}

sub send_describe_cluster_name{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_cluster_name', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_cluster_name_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_cluster_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_cluster_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_cluster_name failed: unknown result";
}
sub describe_version{
  my $self = shift;

    $self->send_describe_version();
  return $self->recv_describe_version();
}

sub send_describe_version{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_version', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_version_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_version{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_version_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_version failed: unknown result";
}
sub describe_ring{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_ring($keyspace);
  return $self->recv_describe_ring();
}

sub send_describe_ring{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_ring', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_ring_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_ring{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_ring_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  die "describe_ring failed: unknown result";
}
sub describe_partitioner{
  my $self = shift;

    $self->send_describe_partitioner();
  return $self->recv_describe_partitioner();
}

sub send_describe_partitioner{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_partitioner', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_partitioner_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_partitioner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_partitioner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_partitioner failed: unknown result";
}
sub describe_snitch{
  my $self = shift;

    $self->send_describe_snitch();
  return $self->recv_describe_snitch();
}

sub send_describe_snitch{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_snitch', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_snitch_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_snitch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_snitch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_snitch failed: unknown result";
}
sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_keyspace($keyspace);
  return $self->recv_describe_keyspace();
}

sub send_describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe}->getName();
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  die "describe_keyspace failed: unknown result";
}
sub describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

    $self->send_describe_splits($cfName, $start_token, $end_token, $keys_per_split);
  return $self->recv_describe_splits();
}

sub send_describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  $self->{output}->writeMessageBegin('describe_splits', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_splits_args();
  $args->{cfName} = $cfName;
  $args->{start_token} = $start_token;
  $args->{end_token} = $end_token;
  $args->{keys_per_split} = $keys_per_split;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_describe_splits_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  die "describe_splits failed: unknown result";
}
sub system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

    $self->send_system_add_column_family($cf_def);
  return $self->recv_system_add_column_family();
}

sub send_system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

  $self->{output}->writeMessageBegin('system_add_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_add_column_family_args();
  $args->{cf_def} = $cf_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_add_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_system_add_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{sde}) {
    die $result->{sde}->getName();
  }
  die "system_add_column_family failed: unknown result";
}
sub system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

    $self->send_system_drop_column_family($column_family);
  return $self->recv_system_drop_column_family();
}

sub send_system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

  $self->{output}->writeMessageBegin('system_drop_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_drop_column_family_args();
  $args->{column_family} = $column_family;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_drop_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_system_drop_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{sde}) {
    die $result->{sde}->getName();
  }
  die "system_drop_column_family failed: unknown result";
}
sub system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

    $self->send_system_add_keyspace($ks_def);
  return $self->recv_system_add_keyspace();
}

sub send_system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

  $self->{output}->writeMessageBegin('system_add_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_add_keyspace_args();
  $args->{ks_def} = $ks_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_add_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_system_add_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{sde}) {
    die $result->{sde}->getName();
  }
  die "system_add_keyspace failed: unknown result";
}
sub system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_system_drop_keyspace($keyspace);
  return $self->recv_system_drop_keyspace();
}

sub send_system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('system_drop_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_drop_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_drop_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_system_drop_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{sde}) {
    die $result->{sde}->getName();
  }
  die "system_drop_keyspace failed: unknown result";
}
sub system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

    $self->send_system_update_keyspace($ks_def);
  return $self->recv_system_update_keyspace();
}

sub send_system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

  $self->{output}->writeMessageBegin('system_update_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_update_keyspace_args();
  $args->{ks_def} = $ks_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_update_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_system_update_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{sde}) {
    die $result->{sde}->getName();
  }
  die "system_update_keyspace failed: unknown result";
}
sub system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

    $self->send_system_update_column_family($cf_def);
  return $self->recv_system_update_column_family();
}

sub send_system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

  $self->{output}->writeMessageBegin('system_update_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_update_column_family_args();
  $args->{cf_def} = $cf_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_update_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_system_update_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{sde}) {
    die $result->{sde}->getName();
  }
  die "system_update_column_family failed: unknown result";
}
sub execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_execute_cql_query($query, $compression);
  return $self->recv_execute_cql_query();
}

sub send_execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('execute_cql_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_execute_cql_query_args();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x->getMessage();
  }
  my $result = new Cassandra::Cassandra_execute_cql_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire}->why;
  }
  if (defined $result->{ue}) {
    die $result->{ue}->getName();
  }
  if (defined $result->{te}) {
    die $result->{te}->getName();
  }
  if (defined $result->{sde}) {
    die $result->{sde}->getName();
  }
  die "execute_cql_query failed: unknown result";
}
package Cassandra::CassandraProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_login {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_login_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_login_result();
    eval {
      $self->{handler}->login($args->auth_request);
    }; if( UNIVERSAL::isa($@,'Cassandra::AuthenticationException') ){ 
      $result->{authnx} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::AuthorizationException') ){ 
      $result->{authzx} = $@;
    }
    $output->writeMessageBegin('login', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_set_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_set_keyspace_result();
    eval {
      $self->{handler}->set_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('set_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_result();
    eval {
      $result->{success} = $self->{handler}->get($args->key, $args->column_path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_slice_result();
    eval {
      $result->{success} = $self->{handler}->get_slice($args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_slice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_count_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_count_result();
    eval {
      $result->{success} = $self->{handler}->get_count($args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_count', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_multiget_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_multiget_slice_result();
    eval {
      $result->{success} = $self->{handler}->multiget_slice($args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('multiget_slice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_multiget_count_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_multiget_count_result();
    eval {
      $result->{success} = $self->{handler}->multiget_count($args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('multiget_count', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_range_slices {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_range_slices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_range_slices_result();
    eval {
      $result->{success} = $self->{handler}->get_range_slices($args->column_parent, $args->predicate, $args->range, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_range_slices', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_indexed_slices {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_indexed_slices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_indexed_slices_result();
    eval {
      $result->{success} = $self->{handler}->get_indexed_slices($args->column_parent, $args->index_clause, $args->column_predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_indexed_slices', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_insert {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_insert_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_insert_result();
    eval {
      $self->{handler}->insert($args->key, $args->column_parent, $args->column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('insert', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_add_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_add_result();
    eval {
      $self->{handler}->add($args->key, $args->column_parent, $args->column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('add', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_remove_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_remove_result();
    eval {
      $self->{handler}->remove($args->key, $args->column_path, $args->timestamp, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('remove', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove_counter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_remove_counter_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_remove_counter_result();
    eval {
      $self->{handler}->remove_counter($args->key, $args->path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('remove_counter', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_batch_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_batch_mutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_batch_mutate_result();
    eval {
      $self->{handler}->batch_mutate($args->mutation_map, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('batch_mutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_truncate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_truncate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_truncate_result();
    eval {
      $self->{handler}->truncate($args->cfname);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('truncate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_schema_versions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_schema_versions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_schema_versions_result();
    eval {
      $result->{success} = $self->{handler}->describe_schema_versions();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_schema_versions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspaces {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_keyspaces_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_keyspaces_result();
    eval {
      $result->{success} = $self->{handler}->describe_keyspaces();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_keyspaces', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_cluster_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_cluster_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_cluster_name_result();
    $result->{success} = $self->{handler}->describe_cluster_name();
    $output->writeMessageBegin('describe_cluster_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_version {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_version_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_version_result();
    $result->{success} = $self->{handler}->describe_version();
    $output->writeMessageBegin('describe_version', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_ring {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_ring_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_ring_result();
    eval {
      $result->{success} = $self->{handler}->describe_ring($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_ring', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_partitioner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_partitioner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_partitioner_result();
    $result->{success} = $self->{handler}->describe_partitioner();
    $output->writeMessageBegin('describe_partitioner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_snitch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_snitch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_snitch_result();
    $result->{success} = $self->{handler}->describe_snitch();
    $output->writeMessageBegin('describe_snitch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->describe_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_splits_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_splits_result();
    eval {
      $result->{success} = $self->{handler}->describe_splits($args->cfName, $args->start_token, $args->end_token, $args->keys_per_split);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_splits', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_add_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_add_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_add_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_add_column_family($args->cf_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_add_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_drop_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_drop_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_drop_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_drop_column_family($args->column_family);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_drop_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_add_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_add_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_add_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_add_keyspace($args->ks_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_add_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_drop_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_drop_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_drop_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_drop_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_drop_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_update_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_update_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_update_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_update_keyspace($args->ks_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_update_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_update_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_update_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_update_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_update_column_family($args->cf_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_update_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_execute_cql_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_execute_cql_query_result();
    eval {
      $result->{success} = $self->{handler}->execute_cql_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('execute_cql_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
