#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Cassandra::ConsistencyLevel;
use constant ONE => 1;
use constant QUORUM => 2;
use constant LOCAL_QUORUM => 3;
use constant EACH_QUORUM => 4;
use constant ALL => 5;
use constant ANY => 6;
use constant TWO => 7;
use constant THREE => 8;
package Cassandra::IndexOperator;
use constant EQ => 0;
use constant GTE => 1;
use constant GT => 2;
use constant LTE => 3;
use constant LT => 4;
package Cassandra::IndexType;
use constant KEYS => 0;
package Cassandra::Compression;
use constant GZIP => 1;
use constant NONE => 2;
package Cassandra::CqlResultType;
use constant ROWS => 1;
use constant VOID => 2;
use constant INT => 3;
package Cassandra::Column;
use base qw(Class::Accessor);
Cassandra::Column->mk_accessors( qw( name value timestamp ttl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  $self->{timestamp} = undef;
  $self->{ttl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{ttl}) {
      $self->{ttl} = $vals->{ttl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{ttl});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ttl}) {
    $xfer += $output->writeFieldBegin('ttl', TType::I32, 4);
    $xfer += $output->writeI32($self->{ttl});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SuperColumn;
use base qw(Class::Accessor);
Cassandra::SuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columns} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Cassandra::Column();
            $xfer += $elem5->read($input);
            push(@{$self->{columns}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter6 (@{$self->{columns}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CounterColumn;
use base qw(Class::Accessor);
Cassandra::CounterColumn->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CounterColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CounterColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::I64, 2);
    $xfer += $output->writeI64($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CounterSuperColumn;
use base qw(Class::Accessor);
Cassandra::CounterSuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CounterSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{columns} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new Cassandra::CounterColumn();
            $xfer += $elem12->read($input);
            push(@{$self->{columns}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CounterSuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter13 (@{$self->{columns}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnOrSuperColumn;
use base qw(Class::Accessor);
Cassandra::ColumnOrSuperColumn->mk_accessors( qw( column super_column counter_column counter_super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column} = undef;
  $self->{super_column} = undef;
  $self->{counter_column} = undef;
  $self->{counter_super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{counter_column}) {
      $self->{counter_column} = $vals->{counter_column};
    }
    if (defined $vals->{counter_super_column}) {
      $self->{counter_super_column} = $vals->{counter_super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnOrSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::Column();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{super_column} = new Cassandra::SuperColumn();
        $xfer += $self->{super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{counter_column} = new Cassandra::CounterColumn();
        $xfer += $self->{counter_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{counter_super_column} = new Cassandra::CounterSuperColumn();
        $xfer += $self->{counter_super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnOrSuperColumn');
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 1);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRUCT, 2);
    $xfer += $self->{super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter_column}) {
    $xfer += $output->writeFieldBegin('counter_column', TType::STRUCT, 3);
    $xfer += $self->{counter_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter_super_column}) {
    $xfer += $output->writeFieldBegin('counter_super_column', TType::STRUCT, 4);
    $xfer += $self->{counter_super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::NotFoundException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'NotFoundException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NotFoundException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::InvalidRequestException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::InvalidRequestException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidRequestException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidRequestException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::UnavailableException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'UnavailableException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnavailableException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TimedOutException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'TimedOutException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TimedOutException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthenticationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthorizationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthorizationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthorizationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthorizationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SchemaDisagreementException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'SchemaDisagreementException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SchemaDisagreementException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnParent;
use base qw(Class::Accessor);
Cassandra::ColumnParent->mk_accessors( qw( column_family super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnParent';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnParent');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnPath;
use base qw(Class::Accessor);
Cassandra::ColumnPath->mk_accessors( qw( column_family super_column column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnPath';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnPath');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 5);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SliceRange;
use base qw(Class::Accessor);
Cassandra::SliceRange->mk_accessors( qw( start finish reversed count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start} = undef;
  $self->{finish} = undef;
  $self->{reversed} = 0;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{reversed}) {
      $self->{reversed} = $vals->{reversed};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SliceRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{reversed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SliceRange');
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::STRING, 1);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', TType::STRING, 2);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{reversed}) {
    $xfer += $output->writeFieldBegin('reversed', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{reversed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 4);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SlicePredicate;
use base qw(Class::Accessor);
Cassandra::SlicePredicate->mk_accessors( qw( column_names slice_range ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_names} = undef;
  $self->{slice_range} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_names}) {
      $self->{column_names} = $vals->{column_names};
    }
    if (defined $vals->{slice_range}) {
      $self->{slice_range} = $vals->{slice_range};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SlicePredicate';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{column_names} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $xfer += $input->readString(\$elem19);
            push(@{$self->{column_names}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{slice_range} = new Cassandra::SliceRange();
        $xfer += $self->{slice_range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SlicePredicate');
  if (defined $self->{column_names}) {
    $xfer += $output->writeFieldBegin('column_names', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{column_names}}));
      {
        foreach my $iter20 (@{$self->{column_names}}) 
        {
          $xfer += $output->writeString($iter20);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{slice_range}) {
    $xfer += $output->writeFieldBegin('slice_range', TType::STRUCT, 2);
    $xfer += $self->{slice_range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::IndexExpression;
use base qw(Class::Accessor);
Cassandra::IndexExpression->mk_accessors( qw( column_name op value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_name} = undef;
  $self->{op} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_name}) {
      $self->{column_name} = $vals->{column_name};
    }
    if (defined $vals->{op}) {
      $self->{op} = $vals->{op};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexExpression';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{op});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexExpression');
  if (defined $self->{column_name}) {
    $xfer += $output->writeFieldBegin('column_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{op}) {
    $xfer += $output->writeFieldBegin('op', TType::I32, 2);
    $xfer += $output->writeI32($self->{op});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::IndexClause;
use base qw(Class::Accessor);
Cassandra::IndexClause->mk_accessors( qw( expressions start_key count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{expressions} = undef;
  $self->{start_key} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{expressions}) {
      $self->{expressions} = $vals->{expressions};
    }
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexClause';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size21 = 0;
          $self->{expressions} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = new Cassandra::IndexExpression();
            $xfer += $elem26->read($input);
            push(@{$self->{expressions}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexClause');
  if (defined $self->{expressions}) {
    $xfer += $output->writeFieldBegin('expressions', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{expressions}}));
      {
        foreach my $iter27 (@{$self->{expressions}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', TType::STRING, 2);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 3);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyRange;
use base qw(Class::Accessor);
Cassandra::KeyRange->mk_accessors( qw( start_key end_key start_token end_token count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_key} = undef;
  $self->{end_key} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{end_key}) {
      $self->{end_key} = $vals->{end_key};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyRange');
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_key}) {
    $xfer += $output->writeFieldBegin('end_key', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 3);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 4);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 5);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeySlice;
use base qw(Class::Accessor);
Cassandra::KeySlice->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeySlice';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{columns} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $elem33 = new Cassandra::ColumnOrSuperColumn();
            $xfer += $elem33->read($input);
            push(@{$self->{columns}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeySlice');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter34 (@{$self->{columns}}) 
        {
          $xfer += ${iter34}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyCount;
use base qw(Class::Accessor);
Cassandra::KeyCount->mk_accessors( qw( key count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{count} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyCount';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyCount');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 2);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Deletion;
use base qw(Class::Accessor);
Cassandra::Deletion->mk_accessors( qw( timestamp super_column predicate ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{timestamp} = undef;
  $self->{super_column} = undef;
  $self->{predicate} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Deletion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Deletion');
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 1);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 2);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Mutation;
use base qw(Class::Accessor);
Cassandra::Mutation->mk_accessors( qw( column_or_supercolumn deletion ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_or_supercolumn} = undef;
  $self->{deletion} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_or_supercolumn}) {
      $self->{column_or_supercolumn} = $vals->{column_or_supercolumn};
    }
    if (defined $vals->{deletion}) {
      $self->{deletion} = $vals->{deletion};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Mutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_or_supercolumn} = new Cassandra::ColumnOrSuperColumn();
        $xfer += $self->{column_or_supercolumn}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{deletion} = new Cassandra::Deletion();
        $xfer += $self->{deletion}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Mutation');
  if (defined $self->{column_or_supercolumn}) {
    $xfer += $output->writeFieldBegin('column_or_supercolumn', TType::STRUCT, 1);
    $xfer += $self->{column_or_supercolumn}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deletion}) {
    $xfer += $output->writeFieldBegin('deletion', TType::STRUCT, 2);
    $xfer += $self->{deletion}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TokenRange;
use base qw(Class::Accessor);
Cassandra::TokenRange->mk_accessors( qw( start_token end_token endpoints ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{endpoints} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{endpoints}) {
      $self->{endpoints} = $vals->{endpoints};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size35 = 0;
          $self->{endpoints} = [];
          my $_etype38 = 0;
          $xfer += $input->readListBegin(\$_etype38, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $elem40 = undef;
            $xfer += $input->readString(\$elem40);
            push(@{$self->{endpoints}},$elem40);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenRange');
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endpoints}) {
    $xfer += $output->writeFieldBegin('endpoints', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{endpoints}}));
      {
        foreach my $iter41 (@{$self->{endpoints}}) 
        {
          $xfer += $output->writeString($iter41);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationRequest;
use base qw(Class::Accessor);
Cassandra::AuthenticationRequest->mk_accessors( qw( credentials ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{credentials} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{credentials}) {
      $self->{credentials} = $vals->{credentials};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size42 = 0;
          $self->{credentials} = {};
          my $_ktype43 = 0;
          my $_vtype44 = 0;
          $xfer += $input->readMapBegin(\$_ktype43, \$_vtype44, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $key47 = '';
            my $val48 = '';
            $xfer += $input->readString(\$key47);
            $xfer += $input->readString(\$val48);
            $self->{credentials}->{$key47} = $val48;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationRequest');
  if (defined $self->{credentials}) {
    $xfer += $output->writeFieldBegin('credentials', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{credentials}}));
      {
        while( my ($kiter49,$viter50) = each %{$self->{credentials}}) 
        {
          $xfer += $output->writeString($kiter49);
          $xfer += $output->writeString($viter50);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnDef;
use base qw(Class::Accessor);
Cassandra::ColumnDef->mk_accessors( qw( name validation_class index_type index_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{validation_class} = undef;
  $self->{index_type} = undef;
  $self->{index_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{validation_class}) {
      $self->{validation_class} = $vals->{validation_class};
    }
    if (defined $vals->{index_type}) {
      $self->{index_type} = $vals->{index_type};
    }
    if (defined $vals->{index_name}) {
      $self->{index_name} = $vals->{index_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{index_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{index_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{validation_class}) {
    $xfer += $output->writeFieldBegin('validation_class', TType::STRING, 2);
    $xfer += $output->writeString($self->{validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_type}) {
    $xfer += $output->writeFieldBegin('index_type', TType::I32, 3);
    $xfer += $output->writeI32($self->{index_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_name}) {
    $xfer += $output->writeFieldBegin('index_name', TType::STRING, 4);
    $xfer += $output->writeString($self->{index_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CfDef;
use base qw(Class::Accessor);
Cassandra::CfDef->mk_accessors( qw( keyspace name column_type comparator_type subcomparator_type comment row_cache_size key_cache_size read_repair_chance column_metadata gc_grace_seconds default_validation_class id min_compaction_threshold max_compaction_threshold row_cache_save_period_in_seconds key_cache_save_period_in_seconds memtable_flush_after_mins memtable_throughput_in_mb memtable_operations_in_millions replicate_on_write merge_shards_chance key_validation_class row_cache_provider key_alias ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{name} = undef;
  $self->{column_type} = "Standard";
  $self->{comparator_type} = "BytesType";
  $self->{subcomparator_type} = undef;
  $self->{comment} = undef;
  $self->{row_cache_size} = 0;
  $self->{key_cache_size} = 200000;
  $self->{read_repair_chance} = 1;
  $self->{column_metadata} = undef;
  $self->{gc_grace_seconds} = undef;
  $self->{default_validation_class} = undef;
  $self->{id} = undef;
  $self->{min_compaction_threshold} = undef;
  $self->{max_compaction_threshold} = undef;
  $self->{row_cache_save_period_in_seconds} = undef;
  $self->{key_cache_save_period_in_seconds} = undef;
  $self->{memtable_flush_after_mins} = undef;
  $self->{memtable_throughput_in_mb} = undef;
  $self->{memtable_operations_in_millions} = undef;
  $self->{replicate_on_write} = undef;
  $self->{merge_shards_chance} = undef;
  $self->{key_validation_class} = undef;
  $self->{row_cache_provider} = "org.apache.cassandra.cache.ConcurrentLinkedHashCacheProvider";
  $self->{key_alias} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{column_type}) {
      $self->{column_type} = $vals->{column_type};
    }
    if (defined $vals->{comparator_type}) {
      $self->{comparator_type} = $vals->{comparator_type};
    }
    if (defined $vals->{subcomparator_type}) {
      $self->{subcomparator_type} = $vals->{subcomparator_type};
    }
    if (defined $vals->{comment}) {
      $self->{comment} = $vals->{comment};
    }
    if (defined $vals->{row_cache_size}) {
      $self->{row_cache_size} = $vals->{row_cache_size};
    }
    if (defined $vals->{key_cache_size}) {
      $self->{key_cache_size} = $vals->{key_cache_size};
    }
    if (defined $vals->{read_repair_chance}) {
      $self->{read_repair_chance} = $vals->{read_repair_chance};
    }
    if (defined $vals->{column_metadata}) {
      $self->{column_metadata} = $vals->{column_metadata};
    }
    if (defined $vals->{gc_grace_seconds}) {
      $self->{gc_grace_seconds} = $vals->{gc_grace_seconds};
    }
    if (defined $vals->{default_validation_class}) {
      $self->{default_validation_class} = $vals->{default_validation_class};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{min_compaction_threshold}) {
      $self->{min_compaction_threshold} = $vals->{min_compaction_threshold};
    }
    if (defined $vals->{max_compaction_threshold}) {
      $self->{max_compaction_threshold} = $vals->{max_compaction_threshold};
    }
    if (defined $vals->{row_cache_save_period_in_seconds}) {
      $self->{row_cache_save_period_in_seconds} = $vals->{row_cache_save_period_in_seconds};
    }
    if (defined $vals->{key_cache_save_period_in_seconds}) {
      $self->{key_cache_save_period_in_seconds} = $vals->{key_cache_save_period_in_seconds};
    }
    if (defined $vals->{memtable_flush_after_mins}) {
      $self->{memtable_flush_after_mins} = $vals->{memtable_flush_after_mins};
    }
    if (defined $vals->{memtable_throughput_in_mb}) {
      $self->{memtable_throughput_in_mb} = $vals->{memtable_throughput_in_mb};
    }
    if (defined $vals->{memtable_operations_in_millions}) {
      $self->{memtable_operations_in_millions} = $vals->{memtable_operations_in_millions};
    }
    if (defined $vals->{replicate_on_write}) {
      $self->{replicate_on_write} = $vals->{replicate_on_write};
    }
    if (defined $vals->{merge_shards_chance}) {
      $self->{merge_shards_chance} = $vals->{merge_shards_chance};
    }
    if (defined $vals->{key_validation_class}) {
      $self->{key_validation_class} = $vals->{key_validation_class};
    }
    if (defined $vals->{row_cache_provider}) {
      $self->{row_cache_provider} = $vals->{row_cache_provider};
    }
    if (defined $vals->{key_alias}) {
      $self->{key_alias} = $vals->{key_alias};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CfDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comparator_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{subcomparator_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comment});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{row_cache_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{key_cache_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{read_repair_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size51 = 0;
          $self->{column_metadata} = [];
          my $_etype54 = 0;
          $xfer += $input->readListBegin(\$_etype54, \$_size51);
          for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
          {
            my $elem56 = undef;
            $elem56 = new Cassandra::ColumnDef();
            $xfer += $elem56->read($input);
            push(@{$self->{column_metadata}},$elem56);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{gc_grace_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{default_validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{min_compaction_threshold});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{max_compaction_threshold});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^19$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{row_cache_save_period_in_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^20$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{key_cache_save_period_in_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^21$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{memtable_flush_after_mins});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^22$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{memtable_throughput_in_mb});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^23$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{memtable_operations_in_millions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^24$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{replicate_on_write});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^25$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{merge_shards_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^26$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key_validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^27$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row_cache_provider});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^28$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key_alias});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CfDef');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_type}) {
    $xfer += $output->writeFieldBegin('column_type', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comparator_type}) {
    $xfer += $output->writeFieldBegin('comparator_type', TType::STRING, 5);
    $xfer += $output->writeString($self->{comparator_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subcomparator_type}) {
    $xfer += $output->writeFieldBegin('subcomparator_type', TType::STRING, 6);
    $xfer += $output->writeString($self->{subcomparator_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comment}) {
    $xfer += $output->writeFieldBegin('comment', TType::STRING, 8);
    $xfer += $output->writeString($self->{comment});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_size}) {
    $xfer += $output->writeFieldBegin('row_cache_size', TType::DOUBLE, 9);
    $xfer += $output->writeDouble($self->{row_cache_size});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_cache_size}) {
    $xfer += $output->writeFieldBegin('key_cache_size', TType::DOUBLE, 11);
    $xfer += $output->writeDouble($self->{key_cache_size});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_repair_chance}) {
    $xfer += $output->writeFieldBegin('read_repair_chance', TType::DOUBLE, 12);
    $xfer += $output->writeDouble($self->{read_repair_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_metadata}) {
    $xfer += $output->writeFieldBegin('column_metadata', TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{column_metadata}}));
      {
        foreach my $iter57 (@{$self->{column_metadata}}) 
        {
          $xfer += ${iter57}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gc_grace_seconds}) {
    $xfer += $output->writeFieldBegin('gc_grace_seconds', TType::I32, 14);
    $xfer += $output->writeI32($self->{gc_grace_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_validation_class}) {
    $xfer += $output->writeFieldBegin('default_validation_class', TType::STRING, 15);
    $xfer += $output->writeString($self->{default_validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 16);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{min_compaction_threshold}) {
    $xfer += $output->writeFieldBegin('min_compaction_threshold', TType::I32, 17);
    $xfer += $output->writeI32($self->{min_compaction_threshold});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_compaction_threshold}) {
    $xfer += $output->writeFieldBegin('max_compaction_threshold', TType::I32, 18);
    $xfer += $output->writeI32($self->{max_compaction_threshold});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_save_period_in_seconds}) {
    $xfer += $output->writeFieldBegin('row_cache_save_period_in_seconds', TType::I32, 19);
    $xfer += $output->writeI32($self->{row_cache_save_period_in_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_cache_save_period_in_seconds}) {
    $xfer += $output->writeFieldBegin('key_cache_save_period_in_seconds', TType::I32, 20);
    $xfer += $output->writeI32($self->{key_cache_save_period_in_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_flush_after_mins}) {
    $xfer += $output->writeFieldBegin('memtable_flush_after_mins', TType::I32, 21);
    $xfer += $output->writeI32($self->{memtable_flush_after_mins});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_throughput_in_mb}) {
    $xfer += $output->writeFieldBegin('memtable_throughput_in_mb', TType::I32, 22);
    $xfer += $output->writeI32($self->{memtable_throughput_in_mb});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_operations_in_millions}) {
    $xfer += $output->writeFieldBegin('memtable_operations_in_millions', TType::DOUBLE, 23);
    $xfer += $output->writeDouble($self->{memtable_operations_in_millions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replicate_on_write}) {
    $xfer += $output->writeFieldBegin('replicate_on_write', TType::BOOL, 24);
    $xfer += $output->writeBool($self->{replicate_on_write});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{merge_shards_chance}) {
    $xfer += $output->writeFieldBegin('merge_shards_chance', TType::DOUBLE, 25);
    $xfer += $output->writeDouble($self->{merge_shards_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_validation_class}) {
    $xfer += $output->writeFieldBegin('key_validation_class', TType::STRING, 26);
    $xfer += $output->writeString($self->{key_validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_provider}) {
    $xfer += $output->writeFieldBegin('row_cache_provider', TType::STRING, 27);
    $xfer += $output->writeString($self->{row_cache_provider});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_alias}) {
    $xfer += $output->writeFieldBegin('key_alias', TType::STRING, 28);
    $xfer += $output->writeString($self->{key_alias});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KsDef;
use base qw(Class::Accessor);
Cassandra::KsDef->mk_accessors( qw( name strategy_class strategy_options replication_factor cf_defs ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{strategy_class} = undef;
  $self->{strategy_options} = undef;
  $self->{replication_factor} = undef;
  $self->{cf_defs} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{strategy_class}) {
      $self->{strategy_class} = $vals->{strategy_class};
    }
    if (defined $vals->{strategy_options}) {
      $self->{strategy_options} = $vals->{strategy_options};
    }
    if (defined $vals->{replication_factor}) {
      $self->{replication_factor} = $vals->{replication_factor};
    }
    if (defined $vals->{cf_defs}) {
      $self->{cf_defs} = $vals->{cf_defs};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KsDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{strategy_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size58 = 0;
          $self->{strategy_options} = {};
          my $_ktype59 = 0;
          my $_vtype60 = 0;
          $xfer += $input->readMapBegin(\$_ktype59, \$_vtype60, \$_size58);
          for (my $_i62 = 0; $_i62 < $_size58; ++$_i62)
          {
            my $key63 = '';
            my $val64 = '';
            $xfer += $input->readString(\$key63);
            $xfer += $input->readString(\$val64);
            $self->{strategy_options}->{$key63} = $val64;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{replication_factor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size65 = 0;
          $self->{cf_defs} = [];
          my $_etype68 = 0;
          $xfer += $input->readListBegin(\$_etype68, \$_size65);
          for (my $_i69 = 0; $_i69 < $_size65; ++$_i69)
          {
            my $elem70 = undef;
            $elem70 = new Cassandra::CfDef();
            $xfer += $elem70->read($input);
            push(@{$self->{cf_defs}},$elem70);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KsDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strategy_class}) {
    $xfer += $output->writeFieldBegin('strategy_class', TType::STRING, 2);
    $xfer += $output->writeString($self->{strategy_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strategy_options}) {
    $xfer += $output->writeFieldBegin('strategy_options', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{strategy_options}}));
      {
        while( my ($kiter71,$viter72) = each %{$self->{strategy_options}}) 
        {
          $xfer += $output->writeString($kiter71);
          $xfer += $output->writeString($viter72);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replication_factor}) {
    $xfer += $output->writeFieldBegin('replication_factor', TType::I32, 4);
    $xfer += $output->writeI32($self->{replication_factor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cf_defs}) {
    $xfer += $output->writeFieldBegin('cf_defs', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cf_defs}}));
      {
        foreach my $iter73 (@{$self->{cf_defs}}) 
        {
          $xfer += ${iter73}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlRow;
use base qw(Class::Accessor);
Cassandra::CqlRow->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlRow';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size74 = 0;
          $self->{columns} = [];
          my $_etype77 = 0;
          $xfer += $input->readListBegin(\$_etype77, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $elem79 = undef;
            $elem79 = new Cassandra::Column();
            $xfer += $elem79->read($input);
            push(@{$self->{columns}},$elem79);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlRow');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter80 (@{$self->{columns}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlResult;
use base qw(Class::Accessor);
Cassandra::CqlResult->mk_accessors( qw( type rows num ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  $self->{rows} = undef;
  $self->{num} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{num}) {
      $self->{num} = $vals->{num};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size81 = 0;
          $self->{rows} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            $elem86 = new Cassandra::CqlRow();
            $xfer += $elem86->read($input);
            push(@{$self->{rows}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{num});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlResult');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 1);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rows}}));
      {
        foreach my $iter87 (@{$self->{rows}}) 
        {
          $xfer += ${iter87}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{num}) {
    $xfer += $output->writeFieldBegin('num', TType::I32, 3);
    $xfer += $output->writeI32($self->{num});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
