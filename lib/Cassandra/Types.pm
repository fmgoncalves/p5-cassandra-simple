#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Cassandra::ConsistencyLevel;
use constant ONE => 1;
use constant QUORUM => 2;
use constant LOCAL_QUORUM => 3;
use constant EACH_QUORUM => 4;
use constant ALL => 5;
use constant ANY => 6;
use constant TWO => 7;
use constant THREE => 8;
package Cassandra::IndexOperator;
use constant EQ => 0;
use constant GTE => 1;
use constant GT => 2;
use constant LTE => 3;
use constant LT => 4;
package Cassandra::IndexType;
use constant KEYS => 0;
use constant CUSTOM => 1;
package Cassandra::Compression;
use constant GZIP => 1;
use constant NONE => 2;
package Cassandra::CqlResultType;
use constant ROWS => 1;
use constant VOID => 2;
use constant INT => 3;
package Cassandra::Column;
use base qw(Class::Accessor);
Cassandra::Column->mk_accessors( qw( name value timestamp ttl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  $self->{timestamp} = undef;
  $self->{ttl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{ttl}) {
      $self->{ttl} = $vals->{ttl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{ttl});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ttl}) {
    $xfer += $output->writeFieldBegin('ttl', TType::I32, 4);
    $xfer += $output->writeI32($self->{ttl});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SuperColumn;
use base qw(Class::Accessor);
Cassandra::SuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columns} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Cassandra::Column();
            $xfer += $elem5->read($input);
            push(@{$self->{columns}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter6 (@{$self->{columns}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CounterColumn;
use base qw(Class::Accessor);
Cassandra::CounterColumn->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CounterColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CounterColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::I64, 2);
    $xfer += $output->writeI64($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CounterSuperColumn;
use base qw(Class::Accessor);
Cassandra::CounterSuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CounterSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{columns} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new Cassandra::CounterColumn();
            $xfer += $elem12->read($input);
            push(@{$self->{columns}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CounterSuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter13 (@{$self->{columns}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnOrSuperColumn;
use base qw(Class::Accessor);
Cassandra::ColumnOrSuperColumn->mk_accessors( qw( column super_column counter_column counter_super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column} = undef;
  $self->{super_column} = undef;
  $self->{counter_column} = undef;
  $self->{counter_super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{counter_column}) {
      $self->{counter_column} = $vals->{counter_column};
    }
    if (defined $vals->{counter_super_column}) {
      $self->{counter_super_column} = $vals->{counter_super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnOrSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::Column();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{super_column} = new Cassandra::SuperColumn();
        $xfer += $self->{super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{counter_column} = new Cassandra::CounterColumn();
        $xfer += $self->{counter_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{counter_super_column} = new Cassandra::CounterSuperColumn();
        $xfer += $self->{counter_super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnOrSuperColumn');
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 1);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRUCT, 2);
    $xfer += $self->{super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter_column}) {
    $xfer += $output->writeFieldBegin('counter_column', TType::STRUCT, 3);
    $xfer += $self->{counter_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter_super_column}) {
    $xfer += $output->writeFieldBegin('counter_super_column', TType::STRUCT, 4);
    $xfer += $self->{counter_super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::NotFoundException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'NotFoundException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NotFoundException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::InvalidRequestException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::InvalidRequestException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidRequestException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidRequestException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::UnavailableException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'UnavailableException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnavailableException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TimedOutException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'TimedOutException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TimedOutException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthenticationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthorizationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthorizationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthorizationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthorizationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SchemaDisagreementException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'SchemaDisagreementException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SchemaDisagreementException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnParent;
use base qw(Class::Accessor);
Cassandra::ColumnParent->mk_accessors( qw( column_family super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnParent';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnParent');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnPath;
use base qw(Class::Accessor);
Cassandra::ColumnPath->mk_accessors( qw( column_family super_column column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnPath';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnPath');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 5);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SliceRange;
use base qw(Class::Accessor);
Cassandra::SliceRange->mk_accessors( qw( start finish reversed count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start} = undef;
  $self->{finish} = undef;
  $self->{reversed} = 0;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{reversed}) {
      $self->{reversed} = $vals->{reversed};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SliceRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{reversed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SliceRange');
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::STRING, 1);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', TType::STRING, 2);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{reversed}) {
    $xfer += $output->writeFieldBegin('reversed', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{reversed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 4);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SlicePredicate;
use base qw(Class::Accessor);
Cassandra::SlicePredicate->mk_accessors( qw( column_names slice_range ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_names} = undef;
  $self->{slice_range} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_names}) {
      $self->{column_names} = $vals->{column_names};
    }
    if (defined $vals->{slice_range}) {
      $self->{slice_range} = $vals->{slice_range};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SlicePredicate';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{column_names} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $xfer += $input->readString(\$elem19);
            push(@{$self->{column_names}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{slice_range} = new Cassandra::SliceRange();
        $xfer += $self->{slice_range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SlicePredicate');
  if (defined $self->{column_names}) {
    $xfer += $output->writeFieldBegin('column_names', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{column_names}}));
      {
        foreach my $iter20 (@{$self->{column_names}}) 
        {
          $xfer += $output->writeString($iter20);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{slice_range}) {
    $xfer += $output->writeFieldBegin('slice_range', TType::STRUCT, 2);
    $xfer += $self->{slice_range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::IndexExpression;
use base qw(Class::Accessor);
Cassandra::IndexExpression->mk_accessors( qw( column_name op value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_name} = undef;
  $self->{op} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_name}) {
      $self->{column_name} = $vals->{column_name};
    }
    if (defined $vals->{op}) {
      $self->{op} = $vals->{op};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexExpression';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{op});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexExpression');
  if (defined $self->{column_name}) {
    $xfer += $output->writeFieldBegin('column_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{op}) {
    $xfer += $output->writeFieldBegin('op', TType::I32, 2);
    $xfer += $output->writeI32($self->{op});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::IndexClause;
use base qw(Class::Accessor);
Cassandra::IndexClause->mk_accessors( qw( expressions start_key count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{expressions} = undef;
  $self->{start_key} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{expressions}) {
      $self->{expressions} = $vals->{expressions};
    }
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexClause';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size21 = 0;
          $self->{expressions} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = new Cassandra::IndexExpression();
            $xfer += $elem26->read($input);
            push(@{$self->{expressions}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexClause');
  if (defined $self->{expressions}) {
    $xfer += $output->writeFieldBegin('expressions', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{expressions}}));
      {
        foreach my $iter27 (@{$self->{expressions}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', TType::STRING, 2);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 3);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyRange;
use base qw(Class::Accessor);
Cassandra::KeyRange->mk_accessors( qw( start_key end_key start_token end_token count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_key} = undef;
  $self->{end_key} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{end_key}) {
      $self->{end_key} = $vals->{end_key};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyRange');
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_key}) {
    $xfer += $output->writeFieldBegin('end_key', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 3);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 4);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 5);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeySlice;
use base qw(Class::Accessor);
Cassandra::KeySlice->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeySlice';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{columns} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $elem33 = new Cassandra::ColumnOrSuperColumn();
            $xfer += $elem33->read($input);
            push(@{$self->{columns}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeySlice');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter34 (@{$self->{columns}}) 
        {
          $xfer += ${iter34}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyCount;
use base qw(Class::Accessor);
Cassandra::KeyCount->mk_accessors( qw( key count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{count} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyCount';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyCount');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 2);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Deletion;
use base qw(Class::Accessor);
Cassandra::Deletion->mk_accessors( qw( timestamp super_column predicate ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{timestamp} = undef;
  $self->{super_column} = undef;
  $self->{predicate} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Deletion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Deletion');
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 1);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 2);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Mutation;
use base qw(Class::Accessor);
Cassandra::Mutation->mk_accessors( qw( column_or_supercolumn deletion ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_or_supercolumn} = undef;
  $self->{deletion} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_or_supercolumn}) {
      $self->{column_or_supercolumn} = $vals->{column_or_supercolumn};
    }
    if (defined $vals->{deletion}) {
      $self->{deletion} = $vals->{deletion};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Mutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_or_supercolumn} = new Cassandra::ColumnOrSuperColumn();
        $xfer += $self->{column_or_supercolumn}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{deletion} = new Cassandra::Deletion();
        $xfer += $self->{deletion}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Mutation');
  if (defined $self->{column_or_supercolumn}) {
    $xfer += $output->writeFieldBegin('column_or_supercolumn', TType::STRUCT, 1);
    $xfer += $self->{column_or_supercolumn}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deletion}) {
    $xfer += $output->writeFieldBegin('deletion', TType::STRUCT, 2);
    $xfer += $self->{deletion}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TokenRange;
use base qw(Class::Accessor);
Cassandra::TokenRange->mk_accessors( qw( start_token end_token endpoints rpc_endpoints ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{endpoints} = undef;
  $self->{rpc_endpoints} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{endpoints}) {
      $self->{endpoints} = $vals->{endpoints};
    }
    if (defined $vals->{rpc_endpoints}) {
      $self->{rpc_endpoints} = $vals->{rpc_endpoints};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size35 = 0;
          $self->{endpoints} = [];
          my $_etype38 = 0;
          $xfer += $input->readListBegin(\$_etype38, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $elem40 = undef;
            $xfer += $input->readString(\$elem40);
            push(@{$self->{endpoints}},$elem40);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size41 = 0;
          $self->{rpc_endpoints} = [];
          my $_etype44 = 0;
          $xfer += $input->readListBegin(\$_etype44, \$_size41);
          for (my $_i45 = 0; $_i45 < $_size41; ++$_i45)
          {
            my $elem46 = undef;
            $xfer += $input->readString(\$elem46);
            push(@{$self->{rpc_endpoints}},$elem46);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenRange');
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endpoints}) {
    $xfer += $output->writeFieldBegin('endpoints', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{endpoints}}));
      {
        foreach my $iter47 (@{$self->{endpoints}}) 
        {
          $xfer += $output->writeString($iter47);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rpc_endpoints}) {
    $xfer += $output->writeFieldBegin('rpc_endpoints', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rpc_endpoints}}));
      {
        foreach my $iter48 (@{$self->{rpc_endpoints}}) 
        {
          $xfer += $output->writeString($iter48);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationRequest;
use base qw(Class::Accessor);
Cassandra::AuthenticationRequest->mk_accessors( qw( credentials ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{credentials} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{credentials}) {
      $self->{credentials} = $vals->{credentials};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size49 = 0;
          $self->{credentials} = {};
          my $_ktype50 = 0;
          my $_vtype51 = 0;
          $xfer += $input->readMapBegin(\$_ktype50, \$_vtype51, \$_size49);
          for (my $_i53 = 0; $_i53 < $_size49; ++$_i53)
          {
            my $key54 = '';
            my $val55 = '';
            $xfer += $input->readString(\$key54);
            $xfer += $input->readString(\$val55);
            $self->{credentials}->{$key54} = $val55;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationRequest');
  if (defined $self->{credentials}) {
    $xfer += $output->writeFieldBegin('credentials', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{credentials}}));
      {
        while( my ($kiter56,$viter57) = each %{$self->{credentials}}) 
        {
          $xfer += $output->writeString($kiter56);
          $xfer += $output->writeString($viter57);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnDef;
use base qw(Class::Accessor);
Cassandra::ColumnDef->mk_accessors( qw( name validation_class index_type index_name index_options ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{validation_class} = undef;
  $self->{index_type} = undef;
  $self->{index_name} = undef;
  $self->{index_options} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{validation_class}) {
      $self->{validation_class} = $vals->{validation_class};
    }
    if (defined $vals->{index_type}) {
      $self->{index_type} = $vals->{index_type};
    }
    if (defined $vals->{index_name}) {
      $self->{index_name} = $vals->{index_name};
    }
    if (defined $vals->{index_options}) {
      $self->{index_options} = $vals->{index_options};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{index_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{index_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size58 = 0;
          $self->{index_options} = {};
          my $_ktype59 = 0;
          my $_vtype60 = 0;
          $xfer += $input->readMapBegin(\$_ktype59, \$_vtype60, \$_size58);
          for (my $_i62 = 0; $_i62 < $_size58; ++$_i62)
          {
            my $key63 = '';
            my $val64 = '';
            $xfer += $input->readString(\$key63);
            $xfer += $input->readString(\$val64);
            $self->{index_options}->{$key63} = $val64;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{validation_class}) {
    $xfer += $output->writeFieldBegin('validation_class', TType::STRING, 2);
    $xfer += $output->writeString($self->{validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_type}) {
    $xfer += $output->writeFieldBegin('index_type', TType::I32, 3);
    $xfer += $output->writeI32($self->{index_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_name}) {
    $xfer += $output->writeFieldBegin('index_name', TType::STRING, 4);
    $xfer += $output->writeString($self->{index_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_options}) {
    $xfer += $output->writeFieldBegin('index_options', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{index_options}}));
      {
        while( my ($kiter65,$viter66) = each %{$self->{index_options}}) 
        {
          $xfer += $output->writeString($kiter65);
          $xfer += $output->writeString($viter66);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CfDef;
use base qw(Class::Accessor);
Cassandra::CfDef->mk_accessors( qw( keyspace name column_type comparator_type subcomparator_type comment row_cache_size key_cache_size read_repair_chance column_metadata gc_grace_seconds default_validation_class id min_compaction_threshold max_compaction_threshold row_cache_save_period_in_seconds key_cache_save_period_in_seconds replicate_on_write merge_shards_chance key_validation_class row_cache_provider key_alias compaction_strategy compaction_strategy_options row_cache_keys_to_save compression_options ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{name} = undef;
  $self->{column_type} = "Standard";
  $self->{comparator_type} = "BytesType";
  $self->{subcomparator_type} = undef;
  $self->{comment} = undef;
  $self->{row_cache_size} = 0;
  $self->{key_cache_size} = 200000;
  $self->{read_repair_chance} = 1;
  $self->{column_metadata} = undef;
  $self->{gc_grace_seconds} = undef;
  $self->{default_validation_class} = undef;
  $self->{id} = undef;
  $self->{min_compaction_threshold} = undef;
  $self->{max_compaction_threshold} = undef;
  $self->{row_cache_save_period_in_seconds} = undef;
  $self->{key_cache_save_period_in_seconds} = undef;
  $self->{replicate_on_write} = undef;
  $self->{merge_shards_chance} = undef;
  $self->{key_validation_class} = undef;
  $self->{row_cache_provider} = undef;
  $self->{key_alias} = undef;
  $self->{compaction_strategy} = undef;
  $self->{compaction_strategy_options} = undef;
  $self->{row_cache_keys_to_save} = undef;
  $self->{compression_options} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{column_type}) {
      $self->{column_type} = $vals->{column_type};
    }
    if (defined $vals->{comparator_type}) {
      $self->{comparator_type} = $vals->{comparator_type};
    }
    if (defined $vals->{subcomparator_type}) {
      $self->{subcomparator_type} = $vals->{subcomparator_type};
    }
    if (defined $vals->{comment}) {
      $self->{comment} = $vals->{comment};
    }
    if (defined $vals->{row_cache_size}) {
      $self->{row_cache_size} = $vals->{row_cache_size};
    }
    if (defined $vals->{key_cache_size}) {
      $self->{key_cache_size} = $vals->{key_cache_size};
    }
    if (defined $vals->{read_repair_chance}) {
      $self->{read_repair_chance} = $vals->{read_repair_chance};
    }
    if (defined $vals->{column_metadata}) {
      $self->{column_metadata} = $vals->{column_metadata};
    }
    if (defined $vals->{gc_grace_seconds}) {
      $self->{gc_grace_seconds} = $vals->{gc_grace_seconds};
    }
    if (defined $vals->{default_validation_class}) {
      $self->{default_validation_class} = $vals->{default_validation_class};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{min_compaction_threshold}) {
      $self->{min_compaction_threshold} = $vals->{min_compaction_threshold};
    }
    if (defined $vals->{max_compaction_threshold}) {
      $self->{max_compaction_threshold} = $vals->{max_compaction_threshold};
    }
    if (defined $vals->{row_cache_save_period_in_seconds}) {
      $self->{row_cache_save_period_in_seconds} = $vals->{row_cache_save_period_in_seconds};
    }
    if (defined $vals->{key_cache_save_period_in_seconds}) {
      $self->{key_cache_save_period_in_seconds} = $vals->{key_cache_save_period_in_seconds};
    }
    if (defined $vals->{replicate_on_write}) {
      $self->{replicate_on_write} = $vals->{replicate_on_write};
    }
    if (defined $vals->{merge_shards_chance}) {
      $self->{merge_shards_chance} = $vals->{merge_shards_chance};
    }
    if (defined $vals->{key_validation_class}) {
      $self->{key_validation_class} = $vals->{key_validation_class};
    }
    if (defined $vals->{row_cache_provider}) {
      $self->{row_cache_provider} = $vals->{row_cache_provider};
    }
    if (defined $vals->{key_alias}) {
      $self->{key_alias} = $vals->{key_alias};
    }
    if (defined $vals->{compaction_strategy}) {
      $self->{compaction_strategy} = $vals->{compaction_strategy};
    }
    if (defined $vals->{compaction_strategy_options}) {
      $self->{compaction_strategy_options} = $vals->{compaction_strategy_options};
    }
    if (defined $vals->{row_cache_keys_to_save}) {
      $self->{row_cache_keys_to_save} = $vals->{row_cache_keys_to_save};
    }
    if (defined $vals->{compression_options}) {
      $self->{compression_options} = $vals->{compression_options};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CfDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comparator_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{subcomparator_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comment});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{row_cache_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{key_cache_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{read_repair_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size67 = 0;
          $self->{column_metadata} = [];
          my $_etype70 = 0;
          $xfer += $input->readListBegin(\$_etype70, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $elem72 = undef;
            $elem72 = new Cassandra::ColumnDef();
            $xfer += $elem72->read($input);
            push(@{$self->{column_metadata}},$elem72);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{gc_grace_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{default_validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{min_compaction_threshold});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{max_compaction_threshold});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^19$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{row_cache_save_period_in_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^20$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{key_cache_save_period_in_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^24$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{replicate_on_write});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^25$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{merge_shards_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^26$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key_validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^27$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row_cache_provider});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^28$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key_alias});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^29$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{compaction_strategy});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^30$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size73 = 0;
          $self->{compaction_strategy_options} = {};
          my $_ktype74 = 0;
          my $_vtype75 = 0;
          $xfer += $input->readMapBegin(\$_ktype74, \$_vtype75, \$_size73);
          for (my $_i77 = 0; $_i77 < $_size73; ++$_i77)
          {
            my $key78 = '';
            my $val79 = '';
            $xfer += $input->readString(\$key78);
            $xfer += $input->readString(\$val79);
            $self->{compaction_strategy_options}->{$key78} = $val79;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^31$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{row_cache_keys_to_save});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^32$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size80 = 0;
          $self->{compression_options} = {};
          my $_ktype81 = 0;
          my $_vtype82 = 0;
          $xfer += $input->readMapBegin(\$_ktype81, \$_vtype82, \$_size80);
          for (my $_i84 = 0; $_i84 < $_size80; ++$_i84)
          {
            my $key85 = '';
            my $val86 = '';
            $xfer += $input->readString(\$key85);
            $xfer += $input->readString(\$val86);
            $self->{compression_options}->{$key85} = $val86;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CfDef');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_type}) {
    $xfer += $output->writeFieldBegin('column_type', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comparator_type}) {
    $xfer += $output->writeFieldBegin('comparator_type', TType::STRING, 5);
    $xfer += $output->writeString($self->{comparator_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subcomparator_type}) {
    $xfer += $output->writeFieldBegin('subcomparator_type', TType::STRING, 6);
    $xfer += $output->writeString($self->{subcomparator_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comment}) {
    $xfer += $output->writeFieldBegin('comment', TType::STRING, 8);
    $xfer += $output->writeString($self->{comment});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_size}) {
    $xfer += $output->writeFieldBegin('row_cache_size', TType::DOUBLE, 9);
    $xfer += $output->writeDouble($self->{row_cache_size});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_cache_size}) {
    $xfer += $output->writeFieldBegin('key_cache_size', TType::DOUBLE, 11);
    $xfer += $output->writeDouble($self->{key_cache_size});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_repair_chance}) {
    $xfer += $output->writeFieldBegin('read_repair_chance', TType::DOUBLE, 12);
    $xfer += $output->writeDouble($self->{read_repair_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_metadata}) {
    $xfer += $output->writeFieldBegin('column_metadata', TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{column_metadata}}));
      {
        foreach my $iter87 (@{$self->{column_metadata}}) 
        {
          $xfer += ${iter87}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gc_grace_seconds}) {
    $xfer += $output->writeFieldBegin('gc_grace_seconds', TType::I32, 14);
    $xfer += $output->writeI32($self->{gc_grace_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_validation_class}) {
    $xfer += $output->writeFieldBegin('default_validation_class', TType::STRING, 15);
    $xfer += $output->writeString($self->{default_validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 16);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{min_compaction_threshold}) {
    $xfer += $output->writeFieldBegin('min_compaction_threshold', TType::I32, 17);
    $xfer += $output->writeI32($self->{min_compaction_threshold});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_compaction_threshold}) {
    $xfer += $output->writeFieldBegin('max_compaction_threshold', TType::I32, 18);
    $xfer += $output->writeI32($self->{max_compaction_threshold});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_save_period_in_seconds}) {
    $xfer += $output->writeFieldBegin('row_cache_save_period_in_seconds', TType::I32, 19);
    $xfer += $output->writeI32($self->{row_cache_save_period_in_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_cache_save_period_in_seconds}) {
    $xfer += $output->writeFieldBegin('key_cache_save_period_in_seconds', TType::I32, 20);
    $xfer += $output->writeI32($self->{key_cache_save_period_in_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replicate_on_write}) {
    $xfer += $output->writeFieldBegin('replicate_on_write', TType::BOOL, 24);
    $xfer += $output->writeBool($self->{replicate_on_write});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{merge_shards_chance}) {
    $xfer += $output->writeFieldBegin('merge_shards_chance', TType::DOUBLE, 25);
    $xfer += $output->writeDouble($self->{merge_shards_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_validation_class}) {
    $xfer += $output->writeFieldBegin('key_validation_class', TType::STRING, 26);
    $xfer += $output->writeString($self->{key_validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_provider}) {
    $xfer += $output->writeFieldBegin('row_cache_provider', TType::STRING, 27);
    $xfer += $output->writeString($self->{row_cache_provider});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_alias}) {
    $xfer += $output->writeFieldBegin('key_alias', TType::STRING, 28);
    $xfer += $output->writeString($self->{key_alias});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compaction_strategy}) {
    $xfer += $output->writeFieldBegin('compaction_strategy', TType::STRING, 29);
    $xfer += $output->writeString($self->{compaction_strategy});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compaction_strategy_options}) {
    $xfer += $output->writeFieldBegin('compaction_strategy_options', TType::MAP, 30);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{compaction_strategy_options}}));
      {
        while( my ($kiter88,$viter89) = each %{$self->{compaction_strategy_options}}) 
        {
          $xfer += $output->writeString($kiter88);
          $xfer += $output->writeString($viter89);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_keys_to_save}) {
    $xfer += $output->writeFieldBegin('row_cache_keys_to_save', TType::I32, 31);
    $xfer += $output->writeI32($self->{row_cache_keys_to_save});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression_options}) {
    $xfer += $output->writeFieldBegin('compression_options', TType::MAP, 32);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{compression_options}}));
      {
        while( my ($kiter90,$viter91) = each %{$self->{compression_options}}) 
        {
          $xfer += $output->writeString($kiter90);
          $xfer += $output->writeString($viter91);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KsDef;
use base qw(Class::Accessor);
Cassandra::KsDef->mk_accessors( qw( name strategy_class strategy_options replication_factor cf_defs durable_writes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{strategy_class} = undef;
  $self->{strategy_options} = undef;
  $self->{replication_factor} = undef;
  $self->{cf_defs} = undef;
  $self->{durable_writes} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{strategy_class}) {
      $self->{strategy_class} = $vals->{strategy_class};
    }
    if (defined $vals->{strategy_options}) {
      $self->{strategy_options} = $vals->{strategy_options};
    }
    if (defined $vals->{replication_factor}) {
      $self->{replication_factor} = $vals->{replication_factor};
    }
    if (defined $vals->{cf_defs}) {
      $self->{cf_defs} = $vals->{cf_defs};
    }
    if (defined $vals->{durable_writes}) {
      $self->{durable_writes} = $vals->{durable_writes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KsDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{strategy_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size92 = 0;
          $self->{strategy_options} = {};
          my $_ktype93 = 0;
          my $_vtype94 = 0;
          $xfer += $input->readMapBegin(\$_ktype93, \$_vtype94, \$_size92);
          for (my $_i96 = 0; $_i96 < $_size92; ++$_i96)
          {
            my $key97 = '';
            my $val98 = '';
            $xfer += $input->readString(\$key97);
            $xfer += $input->readString(\$val98);
            $self->{strategy_options}->{$key97} = $val98;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{replication_factor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size99 = 0;
          $self->{cf_defs} = [];
          my $_etype102 = 0;
          $xfer += $input->readListBegin(\$_etype102, \$_size99);
          for (my $_i103 = 0; $_i103 < $_size99; ++$_i103)
          {
            my $elem104 = undef;
            $elem104 = new Cassandra::CfDef();
            $xfer += $elem104->read($input);
            push(@{$self->{cf_defs}},$elem104);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{durable_writes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KsDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strategy_class}) {
    $xfer += $output->writeFieldBegin('strategy_class', TType::STRING, 2);
    $xfer += $output->writeString($self->{strategy_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strategy_options}) {
    $xfer += $output->writeFieldBegin('strategy_options', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{strategy_options}}));
      {
        while( my ($kiter105,$viter106) = each %{$self->{strategy_options}}) 
        {
          $xfer += $output->writeString($kiter105);
          $xfer += $output->writeString($viter106);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replication_factor}) {
    $xfer += $output->writeFieldBegin('replication_factor', TType::I32, 4);
    $xfer += $output->writeI32($self->{replication_factor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cf_defs}) {
    $xfer += $output->writeFieldBegin('cf_defs', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cf_defs}}));
      {
        foreach my $iter107 (@{$self->{cf_defs}}) 
        {
          $xfer += ${iter107}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{durable_writes}) {
    $xfer += $output->writeFieldBegin('durable_writes', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{durable_writes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlRow;
use base qw(Class::Accessor);
Cassandra::CqlRow->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlRow';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size108 = 0;
          $self->{columns} = [];
          my $_etype111 = 0;
          $xfer += $input->readListBegin(\$_etype111, \$_size108);
          for (my $_i112 = 0; $_i112 < $_size108; ++$_i112)
          {
            my $elem113 = undef;
            $elem113 = new Cassandra::Column();
            $xfer += $elem113->read($input);
            push(@{$self->{columns}},$elem113);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlRow');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter114 (@{$self->{columns}}) 
        {
          $xfer += ${iter114}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlMetadata;
use base qw(Class::Accessor);
Cassandra::CqlMetadata->mk_accessors( qw( name_types value_types default_name_type default_value_type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name_types} = undef;
  $self->{value_types} = undef;
  $self->{default_name_type} = undef;
  $self->{default_value_type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name_types}) {
      $self->{name_types} = $vals->{name_types};
    }
    if (defined $vals->{value_types}) {
      $self->{value_types} = $vals->{value_types};
    }
    if (defined $vals->{default_name_type}) {
      $self->{default_name_type} = $vals->{default_name_type};
    }
    if (defined $vals->{default_value_type}) {
      $self->{default_value_type} = $vals->{default_value_type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlMetadata';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size115 = 0;
          $self->{name_types} = {};
          my $_ktype116 = 0;
          my $_vtype117 = 0;
          $xfer += $input->readMapBegin(\$_ktype116, \$_vtype117, \$_size115);
          for (my $_i119 = 0; $_i119 < $_size115; ++$_i119)
          {
            my $key120 = '';
            my $val121 = '';
            $xfer += $input->readString(\$key120);
            $xfer += $input->readString(\$val121);
            $self->{name_types}->{$key120} = $val121;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size122 = 0;
          $self->{value_types} = {};
          my $_ktype123 = 0;
          my $_vtype124 = 0;
          $xfer += $input->readMapBegin(\$_ktype123, \$_vtype124, \$_size122);
          for (my $_i126 = 0; $_i126 < $_size122; ++$_i126)
          {
            my $key127 = '';
            my $val128 = '';
            $xfer += $input->readString(\$key127);
            $xfer += $input->readString(\$val128);
            $self->{value_types}->{$key127} = $val128;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{default_name_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{default_value_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlMetadata');
  if (defined $self->{name_types}) {
    $xfer += $output->writeFieldBegin('name_types', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{name_types}}));
      {
        while( my ($kiter129,$viter130) = each %{$self->{name_types}}) 
        {
          $xfer += $output->writeString($kiter129);
          $xfer += $output->writeString($viter130);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value_types}) {
    $xfer += $output->writeFieldBegin('value_types', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{value_types}}));
      {
        while( my ($kiter131,$viter132) = each %{$self->{value_types}}) 
        {
          $xfer += $output->writeString($kiter131);
          $xfer += $output->writeString($viter132);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_name_type}) {
    $xfer += $output->writeFieldBegin('default_name_type', TType::STRING, 3);
    $xfer += $output->writeString($self->{default_name_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_value_type}) {
    $xfer += $output->writeFieldBegin('default_value_type', TType::STRING, 4);
    $xfer += $output->writeString($self->{default_value_type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlResult;
use base qw(Class::Accessor);
Cassandra::CqlResult->mk_accessors( qw( type rows num schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  $self->{rows} = undef;
  $self->{num} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{num}) {
      $self->{num} = $vals->{num};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size133 = 0;
          $self->{rows} = [];
          my $_etype136 = 0;
          $xfer += $input->readListBegin(\$_etype136, \$_size133);
          for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
          {
            my $elem138 = undef;
            $elem138 = new Cassandra::CqlRow();
            $xfer += $elem138->read($input);
            push(@{$self->{rows}},$elem138);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{num});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{schema} = new Cassandra::CqlMetadata();
        $xfer += $self->{schema}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlResult');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 1);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rows}}));
      {
        foreach my $iter139 (@{$self->{rows}}) 
        {
          $xfer += ${iter139}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{num}) {
    $xfer += $output->writeFieldBegin('num', TType::I32, 3);
    $xfer += $output->writeI32($self->{num});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 4);
    $xfer += $self->{schema}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
